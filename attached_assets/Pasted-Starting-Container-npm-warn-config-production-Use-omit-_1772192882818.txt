Starting Container
npm warn config production Use `--omit=dev` instead.
> rest-express@1.0.0 start
> NODE_ENV=production node dist/index.cjs
/app/dist/index.cjs:74
		`;await r.execute(v`CREATE SCHEMA IF NOT EXISTS ${v.identifier(a)}`),await r.execute(s);let l=(await r.all(v`select id, hash, created_at from ${v.identifier(a)}.${v.identifier(i)} order by created_at desc limit 1`))[0];await r.transaction(async u=>{for await(let c of e)if(!l||Number(l.created_at)<c.folderMillis){for(let p of c.sql)await u.execute(v.raw(p));await u.execute(v`insert into ${v.identifier(a)}.${v.identifier(i)} ("hash", "created_at") values(${c.hash}, ${c.folderMillis})`)}})}escapeName(e){return`"${e}"`}escapeParam(e){return`$${e+1}`}escapeString(e){return`'${e.replace(/'/g,"''")}'`}buildWithCTE(e){if(!e?.length)return;let r=[v`with `];for(let[n,i]of e.entries())r.push(v`${v.identifier(i._.alias)} as (${i._.sql})`),n<e.length-1&&r.push(v`, `);return r.push(v` `),v.join(r)}buildDeleteQuery({table:e,where:r,returning:n,withList:i}){let a=this.buildWithCTE(i),s=n?v` returning ${this.buildSelection(n,{isSingleTable:!0})}`:void 0,o=r?v` where ${r}`:void 0;return v`${a}delete from ${e}${o}${s}`}buildUpdateSet(e,r){let n=e[k.Symbol.Columns],i=Object.keys(n).filter(s=>r[s]!==void 0||n[s]?.onUpdateFn!==void 0),a=i.length;return v.join(i.flatMap((s,o)=>{let l=n[s],u=r[s]??v.param(l.onUpdateFn(),l),c=v`${v.identifier(this.casing.getColumnCasing(l))} = ${u}`;return o<a-1?[c,v.raw(", ")]:[c]}))}buildUpdateQuery({table:e,set:r,where:n,returning:i,withList:a,from:s,joins:o}){let l=this.buildWithCTE(a),u=e[Ce.Symbol.Name],c=e[Ce.Symbol.Schema],p=e[Ce.Symbol.OriginalName],d=u===p?void 0:u,f=v`${c?v`${v.identifier(c)}.`:void 0}${v.identifier(p)}${d&&v` ${v.identifier(d)}`}`,y=this.buildUpdateSet(e,r),h=s&&v.join([v.raw(" from "),this.buildFromTable(s)]),x=this.buildJoins(o),w=i?v` returning ${this.buildSelection(i,{isSingleTable:!s})}`:void 0,E=n?v` where ${n}`:void 0;return v`${l}update ${f} set ${y}${h}${x}${E}${w}`}buildSelection(e,{isSingleTable:r=!1}={}){let n=e.length,i=e.flatMap(({field:a},s)=>{let o=[];if(b(a,O.Aliased)&&a.isSelectionField)o.push(v.identifier(a.fieldAlias));else if(b(a,O.Aliased)||b(a,O)){let l=b(a,O.Aliased)?a.sql:a;r?o.push(new O(l.queryChunks.map(u=>b(u,_)?v.identifier(this.casing.getColumnCasing(u)):u))):o.push(l),b(a,O.Aliased)&&o.push(v` as ${v.identifier(a.fieldAlias)}`)}else b(a,K)&&(r?o.push(v.identifier(this.casing.getColumnCasing(a))):o.push(a));return s<n-1&&o.push(v`, `),o});return v.join(i)}buildJoins(e){if(!e||e.length===0)return;let r=[];for(let[n,i]of e.entries()){n===0&&r.push(v` `);let a=i.table,s=i.lateral?v` lateral`:void 0;if(b(a,Ce)){let o=a[Ce.Symbol.Name],l=a[Ce.Symbol.Schema],u=a[Ce.Symbol.OriginalName],c=o===u?void 0:i.alias;r.push(v`${v.raw(i.joinType)} join${s} ${l?v`${v.identifier(l)}.`:void 0}${v.identifier(u)}${c&&v` ${v.identifier(c)}`} on ${i.on}`)}else if(b(a,Ie)){let o=a[X].name,l=a[X].schema,u=a[X].originalName,c=o===u?void 0:i.alias;r.push(v`${v.raw(i.joinType)} join${s} ${l?v`${v.identifier(l)}.`:void 0}${v.identifier(u)}${c&&v` ${v.identifier(c)}`} on ${i.on}`)}else r.push(v`${v.raw(i.joinType)} join${s} ${a} on ${i.on}`);n<e.length-1&&r.push(v` `)}return v.join(r)}buildFromTable(e){if(b(e,k)&&e[k.Symbol.OriginalName]!==e[k.Symbol.Name]){let r=v`${v.identifier(e[k.Symbol.OriginalName])}`;return e[k.Symbol.Schema]&&(r=v`${v.identifier(e[k.Symbol.Schema])}.${r}`),v`${r} ${v.identifier(e[k.Symbol.Name])}`}return e}buildSelectQuery({withList:e,fields:r,fieldsFlat:n,where:i,having:a,table:s,joins:o,orderBy:l,groupBy:u,limit:c,offset:p,lockingClause:d,distinct:f,setOperators:y}){let h=n??it(r);for(let ne of h)if(b(ne.field,K)&&$e(ne.field.table)!==(b(s,le)?s._.alias:b(s,pn)?s[X].name:b(s,O)?void 0:$e(s))&&!(de=>o?.some(({alias:wt})=>wt===(de[k.Symbol.IsAlias]?$e(de):de[k.Symbol.BaseName])))(ne.field.table)){let de=$e(ne.field.table);throw new Error(`Your "${ne.path.join("->")}" field references a column "${de}"."${ne.field.name}", but the table "${de}" is not part of the query! Did you forget to join it?`)}let x=!o||o.length===0,w=this.buildWithCTE(e),E;f&&(E=f===!0?v` distinct`:v` distinct on (${v.join(f.on,v`, `)})`);let S=this.buildSelection(h,{isSingleTable:x}),A=this.buildFromTable(s),V=this.buildJoins(o),N=i?v` where ${i}`:void 0,I=a?v` having ${a}`:void 0,j;l&&l.length>0&&(j=v` order by ${v.join(l,v`, `)}`);let z;u&&u.length>0&&(z=v` group by ${v.join(u,v`, `)}`);let Te=typeof c=="object"||typeof c=="number"&&c>=0?v` limit ${c}`:void 0,Rt=p?v` offset ${p}`:void 0,Ve=v.empty();if(d){let ne=v` for ${v.raw(d.strength)}`;d.config.of&&ne.append(v` of ${v.join(Array.isArray(d.config.of)?d.config.of:[d.config.of],v`, `)}`),d.config.noWait?ne.append(v` no wait`):d.config.skipLocked&&ne.append(v` skip locked`),Ve.append(ne)}let ue=v`${w}select${E} ${S} from ${A}${V}${N}${z}${I}${j}${Te}${Rt}${Ve}`;return y.length>0?this.buildSetOperations(ue,y):ue}buildSetOperations(e,r){let[n,...i]=r;if(!...